package AConciseIntroductionToDataStructuresUsingJava.Tree;public class BinarySearchTree<E extends Comparable<? super E>> extends BinaryTree<E> {   // Listing 9.1   public void add(E item){       if(contains(item)) return;       Node<E> last = new Node<>(item,null);       Node<E> n = root;       int comparator = 0;       while(true) {           int result = item.compareTo(n.data);           if (result == 0) {               return;           } else if (result < 0) {               if(comparator > 0){                   last.parent = n.parent;                   last.parent.left = last;                   n.parent = last;                   last.left = n;                   return;               }               comparator = -1;               n = n.left;           } else {               if(comparator < 0){                   last.parent = n.parent;                   last.parent.right = last;                   n.parent = last;                   last.right = n;                   return;               }               comparator = 1;               n = n.right;           }       }   }   public boolean contains(E item) {       return findNode(item, root) != null;   }   public E min(){ //O(h)       Node<E> p = minNode(root);       return p.data;   }   public E max(){ //O(h)       Node<E> p = maxNode(root);       return p.data;   }   public boolean remove(E item){       if(!contains(item)) return false;       Node<E> n = findNode(item,root);       Node<E> father = n.parent;       if(n.left!=null && (father.left==null || father.left==n)) {           father.left = n.left;           n.left.parent = father;       }       if(n.right!=null && (father.right==null || father.right==n)) {           father.right = n.right;           n.right.parent = father;       }       n.parent = null;       n.left = null;       n.right = null;       return true;   }   public E succ(E item){ //O(h)       Node<E> n = findNode(item, root);       if (n == null) return null;       Node<E> succ = succNode(n);       return (succ != null) ? succ.data : null;   }   private Node<E> succNode(Node<E> n){       if (n.right != null) return minNode(n.right);       Node<E> p = n.parent;       while (p != null && p.left != n) {           n = p;           p = n.parent;       }       return p;   }      private Node<E> findNode(E item, Node<E> n) { //O(h)      if (item == null || n == null) return null; //base case if failed      int result = item.compareTo(n.data);      if (result == 0) { //base case if found         return n;      } else if (result < 0) {         return findNode(item, n.left);      } else {         return findNode(item, n.right);      }   }         // Listing 9.2   public E pred(E item) { //O(h)      Node<E> n = findNode(item, root);      if (n == null) return null;      Node<E> pred = predNode(n);      return (pred != null) ? pred.data : null;   }      private Node<E> predNode(Node<E> n) {      if (n.left != null) return maxNode(n.left);      Node<E> p = n.parent;      while (p != null && p.right != n) {         n = p;         p = n.parent;      }      return p;   }    private Node<E> maxNode(Node<E> left) {        while(left.right!=null){            left = left.right;        }        return left;    }    private Node<E> maxNodeRecursive(Node<E> left) {        while(left.right!=null){            maxNodeRecursive(left.right);        }        return left;    }    private Node<E> minNode(Node<E> right){        while(right.left!=null){            right = right.left;        }        return right;    }    private Node<E> minNodeRecursive(Node<E> right) {        while(right.left!=null){            minNodeRecursive(right.left);        }        return right;    }    @Override    public String toString() {        return inorder(root);    }}