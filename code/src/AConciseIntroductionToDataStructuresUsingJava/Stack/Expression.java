package AConciseIntroductionToDataStructuresUsingJava.Stack;public class Expression {    private static final String SPACE = " ";    private static final String PLUS = "+";    private static final String MINUS = "-";    private static final String STAR = "*";    private static final String QUOTIENT = "/";    private static final String POWER = "^";    private static final String LEFT_PARENTHESIS = "(";    private static final String RIGHT_PARENTHESIS = ")";    private static final String LEFT_SQUARE = "[";    private static final String RIGHT_SQUARE = "]";    private static final String LEFT_BRACE = "{";    private static final String RIGHT_BRACE = "}";    private static final String MODULUS = "%";    // Listing 4.6    private static int rank(String op) {        switch (op) {            case POWER:                return 3;            case STAR:            case QUOTIENT:                return 2;            case PLUS:            case MINUS:                return 1;            case LEFT_PARENTHESIS:            case RIGHT_PARENTHESIS:                return 0;            default:                return -1;        }    }    // Listing 4.7    public static String toPostfix(String expr) {        StringBuilder result = new StringBuilder();        Stack<String> operators = new ArrayStack<>();        for (String token : expr.split("\\s+")) {            if (token.equals(LEFT_PARENTHESIS)) operators.push(token);            if (token.equals(RIGHT_PARENTHESIS)) {                while (!operators.isEmpty()) result.append(operators.pop() + SPACE);                result.deleteCharAt(result.length() - 1);            }            if (isOperator(token)) {                while (!operators.isEmpty() &&                        rank(operators.peek()) >= rank(token)) {                    result.append(operators.pop() + SPACE);                }                operators.push(token);            } else {                result.append(token + SPACE);            }        }        while (!operators.isEmpty()) {            result.append(operators.pop() + SPACE);        }        return result.toString();    }    public static boolean isOperator(String op) {        return rank(op) > 0;    }    public static int applyOperator(String operatore, int op1, int op2) throws Exception {        switch (operatore) {            case POWER:                return (int) Math.pow(op1, op2);            case STAR:                return op1 * op2;            case QUOTIENT:                return op1 / op2;            case PLUS:                return op1 + op2;            case MINUS:                return op1 - op2;            case MODULUS:                return op1 % op2;            default:                throw new Exception("Not a valid operator");        }    }    public static int evalPostfix(String postfixExpr) throws Exception {        int result = 0;        int count = 0;        Stack<Integer> operands = new ArrayStack<>();        for (String token : postfixExpr.split("\\s+")) {            if (isOperator(token)) {                int op2;                if(count == 0) op2 = operands.pop();                else op2 = result;                int op1 = operands.pop();                count ++;                result = applyOperator(token, op1, op2);            } else {                operands.push(Integer.valueOf(token));            }        }        return result;    }    public static int eval (String expr) throws Exception {        System.out.println(toPostfix(expr));        return evalPostfix(toPostfix(expr));    }    public static boolean isBalanced(String expr){        int leftParenthesis = 0, rightParenthesis = 0;        int leftSquare = 0, rightSquare = 0;        int leftBrace = 0, rightBrace = 0;        for (String token : expr.split("\\s+")){            if(token.equals(LEFT_PARENTHESIS)) leftParenthesis ++;            else if(token.equals(RIGHT_PARENTHESIS)) rightParenthesis ++;            if(token.equals(LEFT_PARENTHESIS)) leftSquare ++;            else if(token.equals(RIGHT_PARENTHESIS)) rightSquare ++;            if(token.equals(LEFT_PARENTHESIS)) leftBrace ++;            else if(token.equals(RIGHT_PARENTHESIS)) rightBrace ++;        }        return leftParenthesis == rightParenthesis;    }    public static void main (String[]args) throws Exception {        System.out.println(3 + 4 / 2 * (6 - 1));// + 3 * / 4 2 - 6 1        System.out.println(((1 + 3) * 5 - 6) / 2);// / - * + 1 3 5 6 2        System.out.println(4 - (1 + 3 * 2) / 7);// - 4 / + 1 * 3 2 7        System.out.println((5 + 1) * (4 - 2 + 9 / 3));// * + 5 1 + - 4 2 / 9 3        System.out.println(1 - (6 + 4 * 5) / 2);// 1 6 4 5 * + 2 / -        System.out.println(toPostfix("6 * 5 + 3 - 4 / 2"));// 6 5 * 3 + 4 2 / -        System.out.println(((5 + 4) / 3 - 1) * 6 + 2);// 5 4 + 3 / 1 - 6 * 2 +        System.out.println(6 / (2 + 1) - (9 - 1) / 4);// 6 2 1 + / 9 1 - 4 / -        System.out.println(toPostfix("a + b + c + d"));// a b c d + + +        System.out.println(toPostfix("a + b * c - d + e"));// a b c * + d e + -        System.out.println(toPostfix("a * b + c * d - e * f"));// a b * c d * + e f * -        System.out.println(toPostfix("a / b / c + d * e * f"));// a b c / / d e f * * +        System.out.println(eval("1 + 2 * 3"));        System.out.println(isBalanced("6 / ( 2 + 1 ) - ( 9 - 1 ) / 4"));        System.out.println(isBalanced("( 5 + 4 ) / 3 - 1 ) * 6 + 2 )"));    }}