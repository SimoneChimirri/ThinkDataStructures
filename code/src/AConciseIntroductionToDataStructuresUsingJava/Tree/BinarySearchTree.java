package AConciseIntroductionToDataStructuresUsingJava.Tree;public class BinarySearchTree<E extends Comparable<? super E>> extends BinaryTree<E> {   // Listing 9.1   public void add(E item){ // O(h)       if(item == null) return;       if(contains(item)) return;       if(root == null) {           root = new Node<>(item, null);       } else {           addNode(item, root);       }   }   private void addNode(E item, Node<E> n){       assert item != null && n != null;       int comparator = item.compareTo(n.data);       if(comparator < 0) {           if(n.left == null) {               n.left = new Node<>(item, n);           } else {               addNode(item, n.left);           }       } else if(comparator > 0) {           if(n.right == null) {               n.right = new Node<>(item, n);           } else {               addNode(item, n.right);           }       } else{           Node<E> duplicateNode = new Node<>(item, n);           if(n.parent.left==n) {               duplicateNode.parent = n.parent.left;               n.parent.left = duplicateNode;               duplicateNode.left = n;           } else{               duplicateNode.parent = n.parent.right;               n.parent.right = duplicateNode;               duplicateNode.right = n;           }           n.parent = duplicateNode;       }   }   public void addDuplicate(E item){ //O(h)       if(item == null) return;       if(root == null) {           root = new Node<>(item, null);       } else {           addNode(item, root);       }   }   public boolean contains(E item) {       return findNode(item, root) != null;   }   public E min(){ //O(h)       Node<E> p = minNode(root);       return p.data;   }   public E max(){ //O(h)       Node<E> p = maxNode(root);       return p.data;   }   public boolean remove(E item){ // O(h)       if(item == null || !contains(item)) return false;       Node<E> n = findNode(item,root);       return removeNodeFast(n);   }   private boolean removeNodeFast(Node<E> n){       Node<E> leftChild = n.left;       if(n.left != null && n.right != null){           while(leftChild.right!=null) leftChild = leftChild.right;           leftChild.right = n.right;           n.right.parent = leftChild;           n.right = null;       }       return removeNode(n);   }   private boolean removeNode(Node<E> n){       if(n.left != null && n.right != null){           return replace(n, predNode(n)) == null;       }       Node<E> child = (n.left != null) ? n.left : n.right;       if(n == root) {           root = child;           if(child != null) {               child.parent = null;           }       } else {           if(n.parent.left == n) {               n.parent.left = child;           } else {               n.parent.right = child;           }           if(child != null) {               child.parent = n.parent;           }       }       return !contains(n.data);   }   private Node<E> replace(Node<E> n, Node<E> child){       n.data = child.data;       removeNode(child);       n = null;       return n;   }   public E succ(E item){ //O(h)       Node<E> n = findNode(item, root);       if (n == null) return null;       Node<E> succ = succNode(n);       return (succ != null) ? succ.data : null;   }   private Node<E> succNode(Node<E> n){       assert n!= null;       if (n.right != null) return minNode(n.right);       Node<E> p = n.parent;       while (p != null && p.left != n) {           n = p;           p = n.parent;       }       return p;   }      private Node<E> findNode(E item, Node<E> n) { //O(h)      if (item == null || n == null) return null; //base case if failed      int result = item.compareTo(n.data);      if (result == 0) { //base case if found         return n;      } else if (result < 0) {         return findNode(item, n.left);      } else {         return findNode(item, n.right);      }   }         // Listing 9.2   public E pred(E item) { //O(h)      Node<E> n = findNode(item, root);      if (n == null) return null;      Node<E> pred = predNode(n);      return (pred != null) ? pred.data : null;   }      private Node<E> predNode(Node<E> n) {      assert n!= null;      if (n.left != null) return maxNode(n.left);      Node<E> p = n.parent;      while (p != null && p.right != n) {         n = p;         p = n.parent;      }      return p;   }    private Node<E> maxNode(Node<E> left) {        while(left.right!=null){            left = left.right;        }        return left;    }    private Node<E> maxNodeRecursive(Node<E> left) {        while(left.right!=null){            maxNodeRecursive(left.right);        }        return left;    }    private Node<E> minNode(Node<E> right){        while(right.left!=null){            right = right.left;        }        return right;    }    private Node<E> minNodeRecursive(Node<E> right) {        while(right.left!=null){            minNodeRecursive(right.left);        }        return right;    }    @Override    public String toString() {        return inorder(root);    }    public static void main(String[] args){        BinarySearchTree<Integer> a = new BinarySearchTree<>();        BinarySearchTree<Integer> b = new BinarySearchTree<>();        BinarySearchTree<Integer> c = new BinarySearchTree<>();        BinarySearchTree<Integer> d = new BinarySearchTree<>();        BinarySearchTree<Integer> e = new BinarySearchTree<>();        a.add(9);        a.add(10);        a.add(33);        a.add(43);        a.add(73);        a.add(47);        a.add(27);        a.add(67);        a.add(36);        a.add(49);        a.add(59);        a.add(89);        b.add(74);        b.add(25);        b.add(94);        b.add(96);        b.add(67);        b.add(54);        b.add(69);        b.add(80);        b.add(38);        b.add(5);        b.add(23);        b.add(43);        c.add(69);        c.add(49);        c.add(59);        c.add(21);        c.add(61);        c.add(82);        c.add(44);        c.add(91);        c.add(36);        c.add(1);        c.add(95);        c.add(74);        d.add(5);        d.add(38);        d.add(39);        d.add(94);        d.add(95);        d.add(85);        d.add(44);        d.add(88);        d.add(60);        d.add(33);        d.add(1);        d.add(73);        e.add(98);        e.add(65);        e.add(20);        e.add(44);        e.add(49);        e.add(97);        e.add(38);        e.add(75);        e.add(29);        e.add(43);        e.add(30);        e.add(79);        System.out.println(a);        System.out.println(b);        System.out.println(c);        System.out.println(d);        System.out.println(e);        System.out.println(a.contains(73));        System.out.println(a.contains(11));        System.out.println(a.min());        System.out.println(a.max());        System.out.println(a.succ(49));        System.out.println(a.pred(49));        BinarySearchTree<String> tree = new BinarySearchTree<>();        tree.add("Delta");        tree.add("Alpha");        tree.add("Echo");        tree.add("Charlie");        tree.add("Bravo");        System.out.println(tree);        BinarySearchTree<Integer> tree3 = new BinarySearchTree<>();        tree3.add(24);        tree3.add(20);        tree3.add(50);        tree3.add(13);        tree3.add(23);        tree3.add(45);        tree3.add(75);        tree3.add(5);        tree3.add(14);        tree3.add(22);        tree3.add(27);        tree3.add(46);        tree3.add(69);        tree3.add(8);        tree3.add(21);        tree3.add(26);        tree3.add(38);        tree3.add(53);        tree3.add(71);        System.out.println(tree3);        tree3.remove(45);        tree3.remove(75);        tree3.remove(5);        tree3.remove(20);        tree3.remove(24);        tree3.remove(50);        System.out.println(tree3);        BinarySearchTree<Integer> tree4 = new BinarySearchTree<>();        tree4.add(58);        tree4.add(77);        tree4.add(98);        tree4.add(30);        tree4.add(93);        tree4.add(26);        tree4.add(46);        System.out.println(tree4);        while(tree4.root != null){            System.out.println(tree4);            System.out.println(tree4.root.data);            System.out.println(tree4.remove(tree4.root.data));        }        System.out.println(tree4);        BinarySearchTree<Integer> tree5 = new BinarySearchTree<>();        tree5.add(64);        tree5.add(38);        tree5.add(6);        tree5.add(36);        tree5.add(57);        tree5.add(62);        tree5.add(40);        System.out.println(tree5);        while(tree5.root != null){            System.out.println(tree5);            System.out.println(tree5.root.data);            System.out.println(tree5.remove(tree5.root.data));        }        System.out.println(tree5);        BinarySearchTree<Integer> tree6 = new BinarySearchTree<>();        tree6.add(64);        tree6.add(38);        tree6.add(6);        tree6.add(36);        tree6.add(57);        tree6.add(62);        tree6.addDuplicate(57);        tree6.addDuplicate(38);        tree6.add(40);        System.out.println(tree6);    }}